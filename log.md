# 2023/12/7 木
USART2を使って文字の送信がしたい
## やったこと
- mtk3_bspとGPIOとUSARTのレジスタ設定を同じにした。
-> 00 00 00 00を送信するようになった.
## TODO
- クロックの初期設定(startup_clock)
-> USART通信がうまく行くかも

# 2023/12/8 金
USART2を使って文字の送信がしたい -その2
## やったこと
- GPIOとUSARTのレジスタ設定を確認した
-> あってるはず...
- mtk3_bspからstartup_clock()を移植した
-> なんか意図したとおりにUSART2からAが表示された.やったぜ.嬉しい.原因はクロックの同期なのか？...そういえばシリアル通信って同期って意味だった気がする.純粋なAじゃなくて文字化け(FF)がAの前についてくるので調査する必要がある.
## TODO
- 文字列送信
-> 文字送信をループするだけやね
- 文字/文字列受信
-> 使うかわからんから優先度は低め.実装すればシェルが作れる.面白そう
- 文字化けなくす
-> 単純に邪魔なので消したい
(*) cuでみたらない。FFを表示するかどうかはビュアーの実装次第っぽい
- コード整理
-> 雑に書いた処理とか変数をいい感じに分離する.serial.zigを作る
- tm_printf()実装
-> 可変数文字列出力ほしいなぁ
- uTkernelの初期化処理を地道に実装

# 2023/12/9 土
文字送信の改善&コード整理
## やったこと
- ディレクトリ作ってモジュール化した
- 文字列送信関数作った
- tm_printf作ろうとして挫折
-> 素直にstd.fmt.format()移植するか...?
## TODO
- tm_printf()実装
- uTkernelの初期化処理を地道に実装

# 2023/12/10 日
コード整理
## やったこと
- mtk3っぽくファイル作って関数に処理分けた
->大変だったけど進捗としてはカス?
## TODO
- tm_printf()実装
- uTkernelの初期化処理を地道に実装

# 2023/12/11 月
OSっぽく処理始めてぇなぁ
## やったこと
- reset_hdlとかsysinitおおまかに実装
->ENTRY()をリセットハンドラにしたりベクタテーブル(はりぼて)作った.リンクスクリプトはまだ(仮)のまま
- inittaskとかやった
-> あとはtkernelの中身を実装しないとてつけられなさそう
## TODO
- tm_printf()実装
- uTkernelの初期化処理を地道に実装
- tkernel配下やる
- utk3-zigからファイル持ってくる

# 2023/12/13 水
ベクタテーブルをメモリにおいたで
## やったこと
- いろいろ
->lib/*とかベクタテーブルに必要な諸々を作った
- ベクタテーブル設置しようとした.
-> ROMにおいたままやけどなんかうまく動作してる？そもそもなんでRAMに移すのかよくわかってないので調べる.ベクタテーブル書き換えへんしなぁ
## TODO
- tm_printf()実装
- tkernel配下やる
- スケジューラに必要な準備

# ~2023/12/20 水
いろいろやってて書くのさぼってた
## やったこと
- sysinit完成させたい
->inittask作って、初期タスクの生成まではいけた。あとはknl_force_dispatch作ったら終わりやけどアセンブリ書かなあかんからだるい。
- バグ除去/改善
-> いろいろやった。テストコード書かなあかん。特にTkQueueとか。
- ROM to RAM
-> 重い腰上げてついにやった。変数のアドレス確認する感じうまくいってそう？
- デバッグ用に変数(usizeのみ)を出力する関数作った。
-> 値とアドレス確認できて最高。
- Releaseビルドで動かない
-> 前まで動いてた気がするんやけど...とりあえずDebugで作り続けて、後から動いてた時と比較して修正すればいいやろ。
## TODO
- tm_printf()実装
- アセンブリ書く
- 割り込み関係の関数つくる
- デバッグ用の関数とかをlibtmに分ける
- eventFlagとか作る.

# ~2023/12/30 土
ディスパッチにハマってた
## やったこと
- タスク生成からの実行
まだ完全じゃない気がするぜ
- ディスパッチ
なんでうまく動くのかわからん
- inittask, sysinitの完成
多分必要な処理はかけたはず
- usermainの起動
usermainを直接実行じゃなくてタスクとして起動できた
- systick割り込み禁止
systick割り込みを禁止にしたらうまく動いた。謎。とりあえず禁止のまま作って後回しにする
## TODO
- tm_printf()実装
- デバッグ用の関数とかをlibtmに分ける
- eventFlagとか作る.

# 2023/12/31 日
万事うまく行った
## やったこと
- usermain内でタスクの生成と実行
ReleaseSmall,Safeのときだけ実行が移らない(その直前までは行く).
これを除けばちゃんと機能してる
- Releaseビルドできるようにする
過去のpushに戻って確認して、待機用無限ループが最適化でなんかなってたのが原因っぽいのでループ内にnop命令を入れたらちょっと動作はおかしいところあるけどうまく行った
- 現時点のバイナリサイズ
    Debug:   29096 byte
    safe:    52464 byte
    Fast:    51604 byte
    Small:   8528 byte

## TODO
- Imalloc作る
- Queの諸々考える
- tm_printf()実装
- デバッグ用の関数とかをlibtmに分ける
- eventFlagとか作る.

# ~2024/1/5 金
libtm作った.(未完成) 性能記録をとった
## やったこと
- libtm
文字列のフォーマットは作れてない.serialをこっちに移植した感じ.
debug時のみ機能するのが結構良き
- 性能計測
| Build Mode    | Memory Usage    | Binary Size   |  Execute Time  |
|---------------| --------------- |---------------| ---------------|
| Debug         | 3569(3389/180)  | 29256         |  40(usermain)  |
| ReleaseSafe   | 2580(2413/167)  | 20656         |  10(usermain)  |
| ReleaseFast   | 2598(2413/167)  | 20796         |  1110(ミス?)   |
| ReleaseSmall  | 763(596/167)    |  6156         |  10(usermain)  |
| gcc (-O0)     | 763(596/167)    | 15164         |    (usermain)  |
| gcc (-O3)     | 763(596/167)    | 10184         |    (usermain)  |
| gcc (-Os)     | 763(596/167)    |  8140         |    (usermain)  |
| gcc (-Oz)     | 763(596/167)    |  8140         |    (usermain)  |

# ~2024/3/8 金
SP保存してタスクの状態を保持して切り替え(=タスク切り替え?)
## やったこと
- version
0.12.0(beta)にしてたらアプデ入って色々変わってしまって面倒なので0.11.0に固定した。最初からしておくべき
- dispacth
spの保存と復帰が上手く動作していないようなのできちんと書き直した。Naked属性をつけないとbx lrがきちんと動作しない。本家はアセンブリなのでもともとNakedやった可能性あり。でもせっかくアセンブリでない利点のprintf()が使えなくなったので悲しい。
## TODO
- 性能測定
- リファクタリング
- tm_printf()完成させる
- テスト書け
- Queの構造見直せ
